{"ast":null,"code":"var extended = require(\"./../extended\"),\n  has = extended.has,\n  isUndefinedOrNull = extended.isUndefinedOrNull,\n  trim = extended.trim,\n  trimLeft = extended.trimLeft,\n  trimRight = extended.trimRight;\nfunction createParser(options) {\n  options = options || {};\n  var delimiter = options.delimiter || \",\",\n    doLtrim = options.ltrim || false,\n    doRtrim = options.rtrim || false,\n    doTrim = options.trim || false,\n    ESCAPE = has(options, \"quote\") ? options.quote : '\"',\n    VALUE_REGEXP = new RegExp(\"([^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]*(?:\\\\s+[^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]+)*)\"),\n    SEARCH_REGEXP = new RegExp(\"(?:\\\\n|\\\\r|\" + delimiter + \")\"),\n    ESCAPE_CHAR = options.escape || '\"',\n    NEXT_TOKEN_REGEXP = new RegExp(\"([^\\\\s]|\\\\r\\\\n|\\\\n|\\\\r|\" + delimiter + \")\"),\n    ROW_DELIMITER = /(\\r\\n|\\n|\\r)/,\n    COMMENT,\n    hasComments;\n  if (has(options, \"comment\")) {\n    COMMENT = options.comment;\n    hasComments = true;\n  }\n  function formatItem(item) {\n    if (doTrim) {\n      item = trim(item);\n    } else if (doLtrim) {\n      item = trimLeft(item);\n    } else if (doRtrim) {\n      item = trimRight(item);\n    }\n    return item;\n  }\n  function parseEscapedItem(str, items, cursor, hasMoreData) {\n    var depth = 0,\n      ret = [];\n    var startPushing = false,\n      token,\n      i = 0,\n      l = str.length,\n      escapeIsEscape = ESCAPE_CHAR === ESCAPE;\n    if (l) {\n      while (cursor < l && (token = str.charAt(cursor))) {\n        if (token === ESCAPE) {\n          if (!startPushing) {\n            depth++;\n            startPushing = true;\n          } else if (escapeIsEscape && str.charAt(cursor + 1) === ESCAPE) {\n            cursor++;\n            ret[i++] = token;\n          } else if (!escapeIsEscape && ret[i - 1] === ESCAPE_CHAR) {\n            ret[i - 1] = token;\n          } else {\n            if (! --depth) {\n              ++cursor;\n              break;\n            }\n          }\n        } else {\n          ret[i++] = token;\n        }\n        ++cursor;\n      }\n    }\n    ret = ret.join(\"\");\n    var next = getNextToken(str, cursor),\n      nextToken = next.token;\n    if (nextToken && nextToken.search(delimiter) === 0) {\n      if (hasMoreData && next.cursor + 1 >= l) {\n        cursor = null;\n      } else {\n        cursor++;\n      }\n    } else if (depth && !nextToken) {\n      if (hasMoreData) {\n        cursor = null;\n      } else {\n        throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor).replace(/[r\\n]/g, \"\\\\n\" + \"'\"));\n      }\n    } else if (!depth && nextToken && nextToken.search(SEARCH_REGEXP) === -1) {\n      throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor, 10).replace(/[\\r\\n]/g, \"\\\\n\" + \"'\"));\n    } else if (hasMoreData && (!nextToken || !ROW_DELIMITER.test(nextToken))) {\n      cursor = null;\n    }\n    if (cursor !== null) {\n      items.push(formatItem(ret));\n    }\n    return cursor;\n  }\n  function parseCommentLine(line, cursor, hasMoreData) {\n    var nextIndex = line.substr(cursor).search(ROW_DELIMITER);\n    if (nextIndex === -1) {\n      if (hasMoreData) {\n        nextIndex = null;\n      } else {\n        nextIndex = line.length + 1;\n      }\n    } else {\n      nextIndex = cursor + nextIndex + 1; //go past the next line break\n    }\n\n    return nextIndex;\n  }\n  function parseItem(line, items, cursor, hasMoreData) {\n    var searchStr = line.substr(cursor),\n      nextIndex = searchStr.search(SEARCH_REGEXP);\n    if (nextIndex === -1) {\n      if (!VALUE_REGEXP.test(searchStr)) {\n        throw new Error(\"Parse Error: delimiter '\" + delimiter + \"' not found at '\" + searchStr.replace(/\\n/g, \"\\\\n\" + \"'\"));\n      } else {\n        nextIndex = searchStr.length;\n      }\n    }\n    var nextChar = searchStr.charAt(nextIndex);\n    if (nextChar.search(delimiter) !== -1) {\n      if (hasMoreData && cursor + (nextIndex + 1) >= line.length) {\n        cursor = null;\n      } else {\n        items.push(formatItem(searchStr.substr(0, nextIndex)));\n        cursor += nextIndex + 1;\n      }\n    } else if (ROW_DELIMITER.test(nextChar)) {\n      items.push(formatItem(searchStr.substr(0, nextIndex)));\n      cursor += nextIndex;\n    } else if (!hasMoreData) {\n      items.push(formatItem(searchStr.substr(0, nextIndex)));\n      cursor += nextIndex + 1;\n    } else {\n      cursor = null;\n    }\n    return cursor;\n  }\n  function getNextToken(line, cursor) {\n    var token,\n      nextIndex,\n      subStr = line.substr(cursor);\n    if ((nextIndex = subStr.search(NEXT_TOKEN_REGEXP)) !== -1) {\n      token = line[cursor += nextIndex];\n      cursor += subStr.match(NEXT_TOKEN_REGEXP)[1].length - 1;\n    }\n    return {\n      token: token,\n      cursor: cursor\n    };\n  }\n  return function parseLine(line, hasMoreData) {\n    var i = 0,\n      l = line.length,\n      rows = [],\n      items = [],\n      token,\n      nextToken,\n      cursor,\n      lastLineI = 0;\n    while (i < l) {\n      nextToken = getNextToken(line, i);\n      token = nextToken.token;\n      if (isUndefinedOrNull(token)) {\n        i = lastLineI;\n        break;\n      } else if (ROW_DELIMITER.test(token)) {\n        i = nextToken.cursor + 1;\n        if (i < l) {\n          rows.push(items);\n          items = [];\n          lastLineI = i;\n        } else {\n          break;\n        }\n      } else if (hasComments && token === COMMENT) {\n        cursor = parseCommentLine(line, i, hasMoreData);\n        if (cursor === null) {\n          i = lastLineI;\n          break;\n        } else if (cursor < l) {\n          lastLineI = i = cursor;\n        } else {\n          i = cursor;\n          cursor = null;\n          break;\n        }\n      } else {\n        if (token === ESCAPE) {\n          cursor = parseEscapedItem(line, items, nextToken.cursor, hasMoreData);\n        } else {\n          cursor = parseItem(line, items, i, hasMoreData);\n        }\n        if (cursor === null) {\n          i = lastLineI;\n          break;\n        } else {\n          i = cursor;\n        }\n      }\n    }\n    cursor !== null && rows.push(items);\n    return {\n      line: line.substr(i),\n      rows: rows\n    };\n  };\n}\nmodule.exports = createParser;","map":{"version":3,"names":["extended","require","has","isUndefinedOrNull","trim","trimLeft","trimRight","createParser","options","delimiter","doLtrim","ltrim","doRtrim","rtrim","doTrim","ESCAPE","quote","VALUE_REGEXP","RegExp","SEARCH_REGEXP","ESCAPE_CHAR","escape","NEXT_TOKEN_REGEXP","ROW_DELIMITER","COMMENT","hasComments","comment","formatItem","item","parseEscapedItem","str","items","cursor","hasMoreData","depth","ret","startPushing","token","i","l","length","escapeIsEscape","charAt","join","next","getNextToken","nextToken","search","Error","substr","replace","test","push","parseCommentLine","line","nextIndex","parseItem","searchStr","nextChar","subStr","match","parseLine","rows","lastLineI","module","exports"],"sources":["D:/code/Techfriar/week5-task/verifications/node_modules/fast-csv/lib/parser/parser.js"],"sourcesContent":["var extended = require(\"./../extended\"),\n    has = extended.has,\n    isUndefinedOrNull = extended.isUndefinedOrNull,\n    trim = extended.trim,\n    trimLeft = extended.trimLeft,\n    trimRight = extended.trimRight;\n\nfunction createParser(options) {\n    options = options || {};\n    var delimiter = options.delimiter || \",\",\n        doLtrim = options.ltrim || false,\n        doRtrim = options.rtrim || false,\n        doTrim = options.trim || false,\n        ESCAPE = has(options, \"quote\") ? options.quote : '\"',\n        VALUE_REGEXP = new RegExp(\"([^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]*(?:\\\\s+[^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]+)*)\"),\n        SEARCH_REGEXP = new RegExp(\"(?:\\\\n|\\\\r|\" + delimiter + \")\"),\n        ESCAPE_CHAR = options.escape || '\"',\n        NEXT_TOKEN_REGEXP = new RegExp(\"([^\\\\s]|\\\\r\\\\n|\\\\n|\\\\r|\" + delimiter + \")\"),\n        ROW_DELIMITER = /(\\r\\n|\\n|\\r)/,\n        COMMENT, hasComments;\n    if (has(options, \"comment\")) {\n        COMMENT = options.comment;\n        hasComments = true;\n    }\n\n    function formatItem(item) {\n        if (doTrim) {\n            item = trim(item);\n        } else if (doLtrim) {\n            item = trimLeft(item);\n        } else if (doRtrim) {\n            item = trimRight(item);\n        }\n        return item;\n    }\n\n    function parseEscapedItem(str, items, cursor, hasMoreData) {\n        var depth = 0, ret = [];\n        var startPushing = false, token, i = 0, l = str.length, escapeIsEscape = ESCAPE_CHAR === ESCAPE;\n        if (l) {\n            while (cursor < l && (token = str.charAt(cursor))) {\n                if (token === ESCAPE) {\n                    if (!startPushing) {\n                        depth++;\n                        startPushing = true;\n                    } else if (escapeIsEscape && str.charAt(cursor + 1) === ESCAPE) {\n                        cursor++;\n                        ret[i++] = token;\n                    } else if (!escapeIsEscape && ret[i - 1] === ESCAPE_CHAR) {\n                        ret[i - 1] = token;\n                    } else {\n                        if (!(--depth)) {\n                            ++cursor;\n                            break;\n                        }\n                    }\n                } else {\n                    ret[i++] = token;\n                }\n                ++cursor;\n            }\n        }\n        ret = ret.join(\"\");\n        var next = getNextToken(str, cursor),\n            nextToken = next.token;\n        if (nextToken && nextToken.search(delimiter) === 0) {\n            if (hasMoreData && (next.cursor + 1) >= l) {\n                cursor = null;\n            } else {\n                cursor++;\n            }\n        } else if (depth && !nextToken) {\n            if (hasMoreData) {\n                cursor = null;\n            } else {\n                throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor).replace(/[r\\n]/g, \"\\\\n\" + \"'\"));\n            }\n        } else if ((!depth && nextToken && nextToken.search(SEARCH_REGEXP) === -1)) {\n            throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor, 10).replace(/[\\r\\n]/g, \"\\\\n\" + \"'\"));\n        } else if (hasMoreData && (!nextToken || !ROW_DELIMITER.test(nextToken))) {\n            cursor = null;\n        }\n        if (cursor !== null) {\n            items.push(formatItem(ret));\n        }\n        return cursor;\n    }\n\n    function parseCommentLine(line, cursor, hasMoreData) {\n        var nextIndex = line.substr(cursor).search(ROW_DELIMITER);\n        if (nextIndex === -1) {\n            if (hasMoreData) {\n                nextIndex = null;\n            } else {\n                nextIndex = line.length + 1;\n            }\n        } else {\n            nextIndex = (cursor + nextIndex) + 1; //go past the next line break\n        }\n        return nextIndex;\n    }\n\n    function parseItem(line, items, cursor, hasMoreData) {\n        var searchStr = line.substr(cursor),\n            nextIndex = searchStr.search(SEARCH_REGEXP);\n        if (nextIndex === -1) {\n            if (!VALUE_REGEXP.test(searchStr)) {\n                throw new Error(\"Parse Error: delimiter '\" + delimiter + \"' not found at '\" + searchStr.replace(/\\n/g, \"\\\\n\" + \"'\"));\n            } else {\n                nextIndex = searchStr.length;\n            }\n        }\n        var nextChar = searchStr.charAt(nextIndex);\n        if (nextChar.search(delimiter) !== -1) {\n            if (hasMoreData && (cursor + (nextIndex + 1) >= line.length)) {\n                cursor = null;\n            } else {\n                items.push(formatItem(searchStr.substr(0, nextIndex)));\n                cursor += nextIndex + 1;\n            }\n        } else if (ROW_DELIMITER.test(nextChar)) {\n            items.push(formatItem(searchStr.substr(0, nextIndex)));\n            cursor += nextIndex;\n        } else if (!hasMoreData) {\n            items.push(formatItem(searchStr.substr(0, nextIndex)));\n            cursor += nextIndex + 1;\n        } else {\n            cursor = null;\n        }\n\n        return cursor;\n    }\n\n    function getNextToken(line, cursor) {\n        var token, nextIndex, subStr = line.substr(cursor);\n        if ((nextIndex = subStr.search(NEXT_TOKEN_REGEXP)) !== -1) {\n            token = line[cursor += nextIndex];\n            cursor += subStr.match(NEXT_TOKEN_REGEXP)[1].length - 1;\n        }\n        return {token: token, cursor: cursor};\n    }\n\n    return function parseLine(line, hasMoreData) {\n        var i = 0, l = line.length, rows = [], items = [], token, nextToken, cursor, lastLineI = 0;\n        while (i < l) {\n            nextToken = getNextToken(line, i);\n            token = nextToken.token;\n            if (isUndefinedOrNull(token)) {\n                i = lastLineI;\n                break;\n            } else if (ROW_DELIMITER.test(token)) {\n                i = nextToken.cursor + 1;\n                if (i < l) {\n                    rows.push(items);\n                    items = [];\n                    lastLineI = i;\n                } else {\n                    break;\n                }\n            } else if (hasComments && token === COMMENT) {\n                cursor = parseCommentLine(line, i, hasMoreData);\n                if (cursor === null) {\n                    i = lastLineI;\n                    break;\n                } else if (cursor < l) {\n                    lastLineI = i = cursor;\n                } else {\n                    i = cursor;\n                    cursor = null;\n                    break;\n                }\n            } else {\n                if (token === ESCAPE) {\n                    cursor = parseEscapedItem(line, items, nextToken.cursor, hasMoreData);\n                } else {\n                    cursor = parseItem(line, items, i, hasMoreData);\n                }\n                if (cursor === null) {\n                    i = lastLineI;\n                    break;\n                } else {\n                    i = cursor;\n                }\n            }\n\n        }\n        cursor !== null && rows.push(items);\n        return {line: line.substr(i), rows: rows};\n    };\n\n}\nmodule.exports = createParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}