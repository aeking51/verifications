{"ast":null,"code":"var fs = require(\"fs\"),\n  extended = require(\"../extended\"),\n  has = extended.has,\n  isBoolean = extended.isBoolean,\n  isUndefinedOrNull = extended.isUndefinedOrNull,\n  escape = extended.escape,\n  isArray = extended.isArray,\n  keys = extended.keys,\n  stream = require(\"stream\"),\n  LINE_BREAK = extended.LINE_BREAK;\nfunction createQuoteChecker(stream, quoteColumns, quoteHeaders) {\n  var shouldQuote;\n  if (isBoolean(quoteColumns)) {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns;\n      };\n    } else if (isArray(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[index] : quoteColumns;\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns;\n      };\n    }\n  } else if (isArray(quoteColumns)) {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns[index];\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[index] : quoteColumns[index];\n      };\n    }\n  } else {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns[stream.headers[index]];\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns[stream.headers[index]];\n      };\n    }\n  }\n  return shouldQuote;\n}\nfunction createFormatter(options, stream) {\n  options = options || {};\n  var delimiter = options.delimiter || \",\",\n    ESCAPE_REGEXP = new RegExp(\"[\" + delimiter + escape(options.rowDelimiter || LINE_BREAK) + \"']\"),\n    QUOTE = options.quote || '\"',\n    ESCAPE = options.escape || '\"',\n    REPLACE_REGEXP = new RegExp(QUOTE, \"g\"),\n    quoteColumns = has(options, \"quoteColumns\") ? options.quoteColumns : false,\n    quoteHeaders = has(options, \"quoteHeaders\") ? options.quoteHeaders : quoteColumns,\n    shouldQuote = createQuoteChecker(stream, quoteColumns, quoteHeaders);\n  function escapeField(field, index, isHeader) {\n    var escape;\n    field = field.replace(/\\0/g, '');\n    if (escape = field.indexOf(QUOTE) !== -1) {\n      field = field.replace(REPLACE_REGEXP, ESCAPE + QUOTE);\n      escape = true;\n    } else {\n      escape = field.search(ESCAPE_REGEXP) !== -1;\n    }\n    escape = escape || shouldQuote(index, isHeader);\n    if (escape) {\n      field = [QUOTE + field + QUOTE];\n    } else {\n      field = [field];\n    }\n    return field.join(\"\");\n  }\n  return function escapeFields(fields, isHeader) {\n    var i = -1,\n      l = fields.length,\n      ret = [],\n      field;\n    while (++i < l) {\n      field = fields[i];\n      field = (isUndefinedOrNull(field) ? \"\" : field) + \"\";\n      ret.push(escapeField(field, i, isHeader));\n    }\n    return ret.join(delimiter);\n  };\n}\nfunction defaultTransform(row, cb) {\n  return cb(null, row);\n}\nfunction isHashArray(arr) {\n  return isArray(arr) && isArray(arr[0]) && arr[0].length === 2;\n}\n\n//get headers from a row item\nfunction gatherHeaders(item) {\n  var ret, i, l;\n  if (isHashArray(item)) {\n    //lets assume a multidimesional array with item 0 bing the title\n    i = -1;\n    l = item.length;\n    ret = [];\n    while (++i < l) {\n      ret[i] = item[i][0];\n    }\n  } else if (isArray(item)) {\n    ret = item;\n  } else {\n    ret = keys(item);\n  }\n  return ret;\n}\n\n//check if we need to write header return true if we should also write a row\n//could be false if headers is true and the header row(first item) is passed in\nfunction checkHeaders(stream, item) {\n  var headers,\n    ret = true;\n  if (!stream.parsedHeaders) {\n    stream.parsedHeaders = true;\n    headers = stream.headers = gatherHeaders(item);\n    stream.headersLength = headers.length;\n  }\n  if (!stream.hasWrittenHeaders) {\n    stream.totalCount++;\n    stream.push(new Buffer(stream.formatter(stream.headers, true), \"utf8\"));\n    stream.hasWrittenHeaders = true;\n    ret = isHashArray(item) || !isArray(item);\n  }\n  return ret;\n}\n\n//transform an object into a CSV row\nfunction transformHashData(stream, item) {\n  var vals = [],\n    row = [],\n    headers = stream.headers,\n    i = -1,\n    headersLength = stream.headersLength;\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n  while (++i < headersLength) {\n    vals[i] = item[headers[i]];\n  }\n  row.push(stream.formatter(vals));\n  return row.join(\"\");\n}\n\n//transform an array into a CSV row\nfunction transformArrayData(stream, item, cb) {\n  var row = [];\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n  row.push(stream.formatter(item));\n  return row.join(\"\");\n}\n\n//transform an array of two item arrays into a CSV row\nfunction transformHashArrayData(stream, item) {\n  var vals = [],\n    row = [],\n    i = -1,\n    headersLength = stream.headersLength;\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n  while (++i < headersLength) {\n    vals[i] = item[i][1];\n  }\n  row.push(stream.formatter(vals));\n  return row.join(\"\");\n}\n\n//wrapper to determin what transform to run\nfunction transformItem(stream, item) {\n  var ret;\n  if (isArray(item)) {\n    if (isHashArray(item)) {\n      ret = transformHashArrayData(stream, item);\n    } else {\n      ret = transformArrayData(stream, item);\n    }\n  } else {\n    ret = transformHashData(stream, item);\n  }\n  return ret;\n}\nexports.createFormatter = createFormatter;\nexports.transformItem = transformItem;\nexports.checkHeaders = checkHeaders;\nexports.defaultTransform = defaultTransform;","map":{"version":3,"names":["fs","require","extended","has","isBoolean","isUndefinedOrNull","escape","isArray","keys","stream","LINE_BREAK","createQuoteChecker","quoteColumns","quoteHeaders","shouldQuote","index","isHeader","headers","createFormatter","options","delimiter","ESCAPE_REGEXP","RegExp","rowDelimiter","QUOTE","quote","ESCAPE","REPLACE_REGEXP","escapeField","field","replace","indexOf","search","join","escapeFields","fields","i","l","length","ret","push","defaultTransform","row","cb","isHashArray","arr","gatherHeaders","item","checkHeaders","parsedHeaders","headersLength","hasWrittenHeaders","totalCount","Buffer","formatter","transformHashData","vals","transformArrayData","transformHashArrayData","transformItem","exports"],"sources":["D:/code/Techfriar/week5-task/verifications/node_modules/fast-csv/lib/formatter/formatter.js"],"sourcesContent":["var fs = require(\"fs\"),\n    extended = require(\"../extended\"),\n    has = extended.has,\n    isBoolean = extended.isBoolean,\n    isUndefinedOrNull = extended.isUndefinedOrNull,\n    escape = extended.escape,\n    isArray = extended.isArray,\n    keys = extended.keys,\n    stream = require(\"stream\"),\n    LINE_BREAK = extended.LINE_BREAK;\n\nfunction createQuoteChecker(stream, quoteColumns, quoteHeaders) {\n    var shouldQuote;\n    if (isBoolean(quoteColumns)) {\n        if (isBoolean(quoteHeaders)) {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return (isHeader ? quoteHeaders : quoteColumns);\n            };\n        } else if (isArray(quoteHeaders)) {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders[index] : quoteColumns;\n            };\n        } else {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns;\n            };\n        }\n    } else if (isArray(quoteColumns)) {\n        if (isBoolean(quoteHeaders)) {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders : quoteColumns[index];\n            };\n        } else {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders[index] : quoteColumns[index];\n            };\n        }\n    } else {\n        if (isBoolean(quoteHeaders)) {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders : quoteColumns[stream.headers[index]];\n            };\n        } else {\n            shouldQuote = function shouldQuote(index, isHeader) {\n                return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns[stream.headers[index]];\n            };\n        }\n    }\n    return shouldQuote;\n}\n\nfunction createFormatter(options, stream) {\n    options = options || {};\n    var delimiter = options.delimiter || \",\",\n        ESCAPE_REGEXP = new RegExp(\"[\" + delimiter + escape(options.rowDelimiter || LINE_BREAK) + \"']\"),\n        QUOTE = options.quote || '\"',\n        ESCAPE = options.escape || '\"',\n        REPLACE_REGEXP = new RegExp(QUOTE, \"g\"),\n        quoteColumns = has(options, \"quoteColumns\") ? options.quoteColumns : false,\n        quoteHeaders = has(options, \"quoteHeaders\") ? options.quoteHeaders : quoteColumns,\n        shouldQuote = createQuoteChecker(stream, quoteColumns, quoteHeaders);\n\n\n    function escapeField(field, index, isHeader) {\n        var escape;\n        field = field.replace(/\\0/g, '');\n        if ((escape = field.indexOf(QUOTE) !== -1)) {\n            field = field.replace(REPLACE_REGEXP, ESCAPE + QUOTE);\n            escape = true;\n        } else {\n            escape = field.search(ESCAPE_REGEXP) !== -1;\n        }\n        escape = escape || shouldQuote(index, isHeader);\n        if (escape) {\n            field = [QUOTE + field + QUOTE];\n        } else {\n            field = [field];\n        }\n        return field.join(\"\");\n    }\n\n    return function escapeFields(fields, isHeader) {\n        var i = -1, l = fields.length, ret = [], field;\n        while (++i < l) {\n            field = fields[i];\n            field = (isUndefinedOrNull(field) ? \"\" : field) + \"\";\n            ret.push(escapeField(field, i, isHeader));\n        }\n        return ret.join(delimiter);\n    };\n}\n\nfunction defaultTransform(row, cb) {\n    return cb(null, row);\n}\n\n\nfunction isHashArray(arr) {\n    return isArray(arr) && isArray(arr[0]) && arr[0].length === 2;\n}\n\n//get headers from a row item\nfunction gatherHeaders(item) {\n    var ret, i, l;\n    if (isHashArray(item)) {\n        //lets assume a multidimesional array with item 0 bing the title\n        i = -1;\n        l = item.length;\n        ret = [];\n        while (++i < l) {\n            ret[i] = item[i][0];\n        }\n    } else if (isArray(item)) {\n        ret = item;\n    } else {\n        ret = keys(item);\n    }\n    return ret;\n}\n\n//check if we need to write header return true if we should also write a row\n//could be false if headers is true and the header row(first item) is passed in\nfunction checkHeaders(stream, item) {\n    var headers, ret = true;\n    if (!stream.parsedHeaders) {\n        stream.parsedHeaders = true;\n        headers = stream.headers = gatherHeaders(item);\n        stream.headersLength = headers.length;\n    }\n    if (!stream.hasWrittenHeaders) {\n        stream.totalCount++;\n        stream.push(new Buffer(stream.formatter(stream.headers, true), \"utf8\"));\n        stream.hasWrittenHeaders = true;\n        ret = isHashArray(item) || !isArray(item);\n    }\n    return ret;\n}\n\n//transform an object into a CSV row\nfunction transformHashData(stream, item) {\n    var vals = [], row = [], headers = stream.headers, i = -1, headersLength = stream.headersLength;\n    if (stream.totalCount++) {\n        row.push(stream.rowDelimiter);\n    }\n    while (++i < headersLength) {\n        vals[i] = item[headers[i]];\n    }\n    row.push(stream.formatter(vals));\n    return row.join(\"\");\n}\n\n//transform an array into a CSV row\nfunction transformArrayData(stream, item, cb) {\n    var row = [];\n    if (stream.totalCount++) {\n        row.push(stream.rowDelimiter);\n    }\n    row.push(stream.formatter(item));\n    return row.join(\"\");\n}\n\n//transform an array of two item arrays into a CSV row\nfunction transformHashArrayData(stream, item) {\n    var vals = [], row = [], i = -1, headersLength = stream.headersLength;\n    if (stream.totalCount++) {\n        row.push(stream.rowDelimiter);\n    }\n    while (++i < headersLength) {\n        vals[i] = item[i][1];\n    }\n    row.push(stream.formatter(vals));\n    return row.join(\"\");\n}\n\n//wrapper to determin what transform to run\nfunction transformItem(stream, item) {\n    var ret;\n    if (isArray(item)) {\n        if (isHashArray(item)) {\n            ret = transformHashArrayData(stream, item);\n        } else {\n            ret = transformArrayData(stream, item);\n        }\n    } else {\n        ret = transformHashData(stream, item);\n    }\n    return ret;\n}\n\nexports.createFormatter = createFormatter;\nexports.transformItem = transformItem;\nexports.checkHeaders = checkHeaders;\nexports.defaultTransform = defaultTransform;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}