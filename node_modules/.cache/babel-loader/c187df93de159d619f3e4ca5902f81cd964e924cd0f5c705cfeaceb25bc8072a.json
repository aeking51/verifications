{"ast":null,"code":"var extended = require(\"../extended\"),\n  isUndefined = extended.isUndefined,\n  spreadArgs = extended.spreadArgs,\n  util = require(\"util\"),\n  out = process.stdout,\n  stream = require(\"stream\"),\n  EMPTY = /^\\s*(?:''|\"\")?\\s*(?:,\\s*(?:''|\"\")?\\s*)*$/,\n  DEFAULT_DELIMITER = \",\",\n  createParser = require(\"./parser\"),\n  fs = require(\"fs\"),\n  hasIsPaused = !!stream.Transform.prototype.isPaused;\nfunction ParserStream(options) {\n  options = options || {};\n  options.objectMode = extended.has(options, \"objectMode\") ? options.objectMode : true;\n  stream.Transform.call(this, options);\n  this.lines = \"\";\n  this._parsedHeaders = false;\n  this._rowCount = -1;\n  this._emitData = false;\n  var delimiter;\n  if (extended.has(options, \"delimiter\")) {\n    delimiter = options.delimiter;\n    if (delimiter.length > 1) {\n      throw new Error(\"delimiter option must be one character long\");\n    }\n    delimiter = extended.escape(delimiter);\n  } else {\n    delimiter = DEFAULT_DELIMITER;\n  }\n  options.delimiter = delimiter;\n  this.parser = createParser(options);\n  this._headers = options.headers;\n  this._ignoreEmpty = options.ignoreEmpty;\n  this._discardUnmappedColumns = options.discardUnmappedColumns;\n  this._strictColumnHandling = options.strictColumnHandling;\n  this.__objectMode = options.objectMode;\n  this.__buffered = [];\n  return this;\n}\nutil.inherits(ParserStream, stream.Transform);\nvar origOn = ParserStream.prototype.on,\n  origEmit = ParserStream.prototype.emit;\nextended(ParserStream).extend({\n  __pausedDone: null,\n  __endEmitted: false,\n  __emittedData: false,\n  __handleLine: function __parseLineData(line, index, ignore, next) {\n    var ignoreEmpty = this._ignoreEmpty,\n      self = this;\n    if (extended.isBoolean(ignoreEmpty) && ignoreEmpty && (!line || EMPTY.test(line.join(\"\")))) {\n      return next(null, null);\n    }\n    if (!ignore) {\n      this.__transform(line, function (err, line) {\n        if (err) {\n          next(err);\n        } else {\n          self.__validate(line, function (err, isValid) {\n            if (err) {\n              next(err);\n            } else if (isValid) {\n              next(null, line);\n            } else {\n              self.emit(\"data-invalid\", line, index);\n              next(null, null);\n            }\n          });\n        }\n      });\n    } else {\n      return next(null, line);\n    }\n  },\n  __processRows: function (rows, data, cb) {\n    var self = this,\n      count;\n    extended.asyncEach(rows, function (row, cb) {\n      if (row) {\n        self.__handleLine(row, count = ++self._rowCount, false, function (err, dataRow) {\n          if (err) {\n            cb(err);\n          } else {\n            if (dataRow) {\n              if (!self.isStreamPaused()) {\n                self.__emitRecord(dataRow, count);\n              } else {\n                self.__buffered.push([dataRow, count]);\n              }\n            } else {\n              count = --self._rowCount;\n            }\n            cb();\n          }\n        });\n      }\n    }, function (err) {\n      if (err) {\n        cb(err);\n      } else {\n        cb(null, data.line);\n      }\n    });\n  },\n  __processHeaders: function (rows, cb) {\n    var headers = this._headers,\n      discardUnmappedColumns = this._discardUnmappedColumns,\n      strictColumnHandling = this._strictColumnHandling,\n      self = this;\n    function headerHandler(err, headers) {\n      if (err) {\n        cb(err);\n      } else if (extended.isArray(headers)) {\n        var headersLength = headers.length,\n          orig = self.__transform;\n        self.__transform = function (data, cb) {\n          var ret = {},\n            i = -1,\n            val;\n          if (data.length > headersLength) {\n            if (discardUnmappedColumns) {\n              data.splice(headersLength);\n            } else if (strictColumnHandling) {\n              self.emit(\"data-invalid\", data);\n              return orig(null, cb);\n            } else {\n              self.emit(\"error\", new Error(\"Unexpected Error: column header mismatch expected: \" + headersLength + \" columns got: \" + data.length));\n              return orig(null, cb);\n            }\n          } else if (strictColumnHandling && data.length < headersLength) {\n            self.emit(\"data-invalid\", data);\n            return orig(null, cb);\n          }\n          while (++i < headersLength) {\n            val = data[i];\n            ret[headers[i]] = isUndefined(val) ? '' : val;\n          }\n          return orig(ret, cb);\n        };\n      }\n      self._parsedHeaders = true;\n      cb(null);\n    }\n    if (extended.isBoolean(headers) && headers) {\n      this.__handleLine(rows.shift(), 0, true, headerHandler);\n    } else {\n      headerHandler(null, headers);\n    }\n  },\n  _parse: function _parseLine(data, hasMoreData, cb) {\n    var rows,\n      self = this;\n    try {\n      data = this.parser(data, hasMoreData);\n      rows = data.rows;\n      if (rows.length) {\n        if (!this._parsedHeaders) {\n          this.__processHeaders(rows, function (err) {\n            if (err) {\n              cb(err);\n            } else {\n              self.__processRows(rows, data, cb);\n            }\n          });\n        } else {\n          this.__processRows(rows, data, cb);\n        }\n      } else {\n        cb(null, data.line);\n      }\n    } catch (e) {\n      cb(e);\n    }\n  },\n  __emitRecord: function (dataRow, count) {\n    this.emit(\"record\", dataRow, count);\n    if (this._emitData) {\n      this.push(this.__objectMode ? dataRow : JSON.stringify(dataRow));\n    }\n  },\n  _transform: function (data, encoding, done) {\n    var lines = this.lines,\n      lineData = lines + data,\n      self = this;\n    if (lineData.length > 1) {\n      this._parse(lineData, true, function (err, lineData) {\n        if (err) {\n          done(err);\n        } else {\n          self.lines = lineData;\n          if (!self.isStreamPaused()) {\n            done();\n          } else {\n            self.__pausedDone = done;\n          }\n        }\n      });\n    } else {\n      this.lines = lineData;\n      if (!this.isStreamPaused()) {\n        done();\n      } else {\n        this.__pausedDone = done;\n      }\n    }\n  },\n  __doFlush: function (callback) {\n    try {\n      callback();\n    } catch (e) {\n      callback(e);\n    }\n  },\n  _flush: function (callback) {\n    var self = this;\n    if (this.lines) {\n      this._parse(this.lines, false, function (err) {\n        if (err) {\n          callback(err);\n        } else if (!self.isStreamPaused()) {\n          self.__doFlush(callback);\n        } else {\n          self.__pausedDone = function () {\n            self.__doFlush(callback);\n          };\n        }\n      });\n    } else {\n      if (!this.isStreamPaused()) {\n        this.__doFlush(callback);\n      } else {\n        this.__pausedDone = function () {\n          self.__doFlush(callback);\n        };\n      }\n    }\n  },\n  __validate: function (data, next) {\n    return next(null, true);\n  },\n  __transform: function (data, next) {\n    return next(null, data);\n  },\n  __flushPausedBuffer: function () {\n    var buffered = this.__buffered,\n      l = buffered.length;\n    if (l) {\n      var entry;\n      while (buffered.length) {\n        entry = buffered.shift();\n        this.__emitRecord(entry[0], entry[1]);\n        //handle case where paused is called while emitting data\n        if (this.isStreamPaused()) {\n          return;\n        }\n      }\n      buffered.length = 0;\n    }\n    if (this.__pausedDone) {\n      var done = this.__pausedDone;\n      this.__pausedDone = null;\n      done();\n    }\n  },\n  isStreamPaused: function () {\n    return this.__paused;\n  },\n  emit: function (event) {\n    if (event === \"end\") {\n      if (!this.__endEmitted) {\n        this.__endEmitted = true;\n        spreadArgs(origEmit, [\"end\", ++this._rowCount], this);\n      }\n    } else {\n      if (!hasIsPaused) {\n        if (event === \"pause\") {\n          this.__paused = true;\n        } else if (event === \"resume\") {\n          this.__paused = false;\n          this.__flushPausedBuffer();\n        }\n      }\n      spreadArgs(origEmit, arguments, this);\n    }\n  },\n  on: function (evt) {\n    if (evt === \"data\" || evt === \"readable\") {\n      this._emitData = true;\n    }\n    spreadArgs(origOn, arguments, this);\n    return this;\n  },\n  validate: function (cb) {\n    if (!extended.isFunction(cb)) {\n      this.emit(\"error\", new TypeError(\"fast-csv.Parser#validate requires a function\"));\n    }\n    if (cb.length === 2) {\n      this.__validate = cb;\n    } else {\n      this.__validate = function (data, next) {\n        return next(null, cb(data));\n      };\n    }\n    return this;\n  },\n  transform: function (cb) {\n    if (!extended.isFunction(cb)) {\n      this.emit(\"error\", new TypeError(\"fast-csv.Parser#transform requires a function\"));\n    }\n    if (cb.length === 2) {\n      this.__transform = cb;\n    } else {\n      this.__transform = function (data, next) {\n        return next(null, cb(data));\n      };\n    }\n    return this;\n  }\n});\nmodule.exports = ParserStream;","map":{"version":3,"names":["extended","require","isUndefined","spreadArgs","util","out","process","stdout","stream","EMPTY","DEFAULT_DELIMITER","createParser","fs","hasIsPaused","Transform","prototype","isPaused","ParserStream","options","objectMode","has","call","lines","_parsedHeaders","_rowCount","_emitData","delimiter","length","Error","escape","parser","_headers","headers","_ignoreEmpty","ignoreEmpty","_discardUnmappedColumns","discardUnmappedColumns","_strictColumnHandling","strictColumnHandling","__objectMode","__buffered","inherits","origOn","on","origEmit","emit","extend","__pausedDone","__endEmitted","__emittedData","__handleLine","__parseLineData","line","index","ignore","next","self","isBoolean","test","join","__transform","err","__validate","isValid","__processRows","rows","data","cb","count","asyncEach","row","dataRow","isStreamPaused","__emitRecord","push","__processHeaders","headerHandler","isArray","headersLength","orig","ret","i","val","splice","shift","_parse","_parseLine","hasMoreData","e","JSON","stringify","_transform","encoding","done","lineData","__doFlush","callback","_flush","__flushPausedBuffer","buffered","l","entry","__paused","event","arguments","evt","validate","isFunction","TypeError","transform","module","exports"],"sources":["D:/code/Techfriar/week5-task/verifications/node_modules/fast-csv/lib/parser/parser_stream.js"],"sourcesContent":["var extended = require(\"../extended\"),\n    isUndefined = extended.isUndefined,\n    spreadArgs = extended.spreadArgs,\n    util = require(\"util\"),\n    out = process.stdout,\n    stream = require(\"stream\"),\n    EMPTY = /^\\s*(?:''|\"\")?\\s*(?:,\\s*(?:''|\"\")?\\s*)*$/,\n    DEFAULT_DELIMITER = \",\",\n    createParser = require(\"./parser\"),\n    fs = require(\"fs\"),\n    hasIsPaused = !!stream.Transform.prototype.isPaused;\n\nfunction ParserStream(options) {\n    options = options || {};\n    options.objectMode = extended.has(options, \"objectMode\") ? options.objectMode : true;\n    stream.Transform.call(this, options);\n    this.lines = \"\";\n    this._parsedHeaders = false;\n    this._rowCount = -1;\n    this._emitData = false;\n    var delimiter;\n    if (extended.has(options, \"delimiter\")) {\n        delimiter = options.delimiter;\n        if (delimiter.length > 1) {\n            throw new Error(\"delimiter option must be one character long\");\n        }\n        delimiter = extended.escape(delimiter);\n    } else {\n        delimiter = DEFAULT_DELIMITER;\n    }\n    options.delimiter = delimiter;\n    this.parser = createParser(options);\n    this._headers = options.headers;\n    this._ignoreEmpty = options.ignoreEmpty;\n    this._discardUnmappedColumns = options.discardUnmappedColumns;\n    this._strictColumnHandling = options.strictColumnHandling;\n    this.__objectMode = options.objectMode;\n    this.__buffered = [];\n    return this;\n}\n\nutil.inherits(ParserStream, stream.Transform);\n\nvar origOn = ParserStream.prototype.on,\n    origEmit = ParserStream.prototype.emit;\n\n\nextended(ParserStream).extend({\n\n    __pausedDone: null,\n\n    __endEmitted: false,\n\n    __emittedData: false,\n\n    __handleLine: function __parseLineData(line, index, ignore, next) {\n        var ignoreEmpty = this._ignoreEmpty, self = this;\n        if (extended.isBoolean(ignoreEmpty) && ignoreEmpty && (!line || EMPTY.test(line.join(\"\")))) {\n            return next(null, null);\n        }\n        if (!ignore) {\n            this.__transform(line, function (err, line) {\n                if (err) {\n                    next(err);\n                } else {\n                    self.__validate(line, function (err, isValid) {\n                        if (err) {\n                            next(err);\n                        } else if (isValid) {\n                            next(null, line);\n                        } else {\n                            self.emit(\"data-invalid\", line, index);\n                            next(null, null);\n                        }\n                    });\n                }\n            });\n        } else {\n            return next(null, line);\n        }\n    },\n\n    __processRows: function (rows, data, cb) {\n        var self = this, count;\n        extended.asyncEach(rows, function (row, cb) {\n            if (row) {\n                self.__handleLine(row, (count = ++self._rowCount), false, function (err, dataRow) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        if (dataRow) {\n                            if (!self.isStreamPaused()) {\n                                self.__emitRecord(dataRow, count);\n                            } else {\n                                self.__buffered.push([dataRow, count]);\n                            }\n                        } else {\n                            count = --self._rowCount;\n                        }\n                        cb();\n                    }\n                });\n            }\n        }, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, data.line);\n            }\n        });\n    },\n\n    __processHeaders: function (rows, cb) {\n        var headers = this._headers,\n            discardUnmappedColumns = this._discardUnmappedColumns,\n            strictColumnHandling = this._strictColumnHandling,\n            self = this;\n\n        function headerHandler(err, headers) {\n            if (err) {\n                cb(err);\n            } else if (extended.isArray(headers)) {\n                var headersLength = headers.length,\n                    orig = self.__transform;\n                self.__transform = function (data, cb) {\n                    var ret = {}, i = -1, val;\n                    if (data.length > headersLength) {\n                        if (discardUnmappedColumns) {\n                            data.splice(headersLength);\n                        } else if (strictColumnHandling) {\n                            self.emit(\"data-invalid\", data);\n                            return orig(null, cb);\n                        } else {\n                            self.emit(\"error\", new Error(\"Unexpected Error: column header mismatch expected: \" + headersLength + \" columns got: \" + data.length));\n                            return orig(null, cb);\n                        }\n                    } else if (strictColumnHandling && (data.length < headersLength)) {\n                        self.emit(\"data-invalid\", data);\n                        return orig(null, cb);\n                    }\n                    while (++i < headersLength) {\n                        val = data[i];\n                        ret[headers[i]] = isUndefined(val) ? '' : val;\n                    }\n\n                    return orig(ret, cb);\n                };\n            }\n            self._parsedHeaders = true;\n            cb(null);\n        }\n\n        if (extended.isBoolean(headers) && headers) {\n            this.__handleLine(rows.shift(), 0, true, headerHandler);\n        } else {\n            headerHandler(null, headers);\n        }\n\n    },\n\n    _parse: function _parseLine(data, hasMoreData, cb) {\n        var rows, self = this;\n        try {\n            data = this.parser(data, hasMoreData);\n            rows = data.rows;\n            if (rows.length) {\n                if (!this._parsedHeaders) {\n                    this.__processHeaders(rows, function (err) {\n                        if (err) {\n                            cb(err);\n                        } else {\n                            self.__processRows(rows, data, cb);\n                        }\n                    });\n                } else {\n                    this.__processRows(rows, data, cb);\n                }\n            } else {\n                cb(null, data.line);\n            }\n        } catch (e) {\n            cb(e);\n        }\n    },\n\n    __emitRecord: function (dataRow, count) {\n        this.emit(\"record\", dataRow, count);\n        if (this._emitData) {\n            this.push(this.__objectMode ? dataRow : JSON.stringify(dataRow));\n        }\n    },\n\n    _transform: function (data, encoding, done) {\n        var lines = this.lines,\n            lineData = (lines + data),\n            self = this;\n        if (lineData.length > 1) {\n            this._parse(lineData, true, function (err, lineData) {\n                if (err) {\n                    done(err);\n                } else {\n                    self.lines = lineData;\n                    if (!self.isStreamPaused()) {\n                        done();\n                    } else {\n                        self.__pausedDone = done;\n                    }\n                }\n            });\n        } else {\n            this.lines = lineData;\n            if (!this.isStreamPaused()) {\n                done();\n            } else {\n                this.__pausedDone = done;\n            }\n        }\n\n    },\n\n    __doFlush: function (callback) {\n        try {\n            callback();\n        } catch (e) {\n            callback(e);\n        }\n    },\n\n    _flush: function (callback) {\n        var self = this;\n        if (this.lines) {\n            this._parse(this.lines, false, function (err) {\n                if (err) {\n                    callback(err);\n                } else if (!self.isStreamPaused()) {\n                    self.__doFlush(callback);\n                } else {\n                    self.__pausedDone = function () {\n                        self.__doFlush(callback);\n                    };\n                }\n            });\n        } else {\n            if (!this.isStreamPaused()) {\n                this.__doFlush(callback);\n            } else {\n                this.__pausedDone = function () {\n                    self.__doFlush(callback);\n                };\n            }\n        }\n    },\n\n    __validate: function (data, next) {\n        return next(null, true);\n    },\n\n    __transform: function (data, next) {\n        return next(null, data);\n    },\n\n    __flushPausedBuffer: function () {\n        var buffered = this.__buffered, l = buffered.length;\n        if (l) {\n            var entry;\n            while (buffered.length) {\n                entry = buffered.shift();\n                this.__emitRecord(entry[0], entry[1]);\n                //handle case where paused is called while emitting data\n                if (this.isStreamPaused()) {\n                    return;\n                }\n            }\n            buffered.length = 0;\n        }\n        if (this.__pausedDone) {\n            var done = this.__pausedDone;\n            this.__pausedDone = null;\n            done();\n        }\n    },\n\n    isStreamPaused: function () {\n        return this.__paused;\n    },\n\n    emit: function (event) {\n        if (event === \"end\") {\n            if (!this.__endEmitted) {\n                this.__endEmitted = true;\n                spreadArgs(origEmit, [\"end\", ++this._rowCount], this);\n            }\n        } else {\n            if (!hasIsPaused) {\n                if (event === \"pause\") {\n                    this.__paused = true;\n                } else if (event === \"resume\") {\n                    this.__paused = false;\n                    this.__flushPausedBuffer();\n                }\n            }\n            spreadArgs(origEmit, arguments, this);\n        }\n    },\n\n    on: function (evt) {\n        if (evt === \"data\" || evt === \"readable\") {\n            this._emitData = true;\n        }\n        spreadArgs(origOn, arguments, this);\n        return this;\n    },\n\n    validate: function (cb) {\n        if (!extended.isFunction(cb)) {\n            this.emit(\"error\", new TypeError(\"fast-csv.Parser#validate requires a function\"));\n        }\n        if (cb.length === 2) {\n            this.__validate = cb;\n        } else {\n            this.__validate = function (data, next) {\n                return next(null, cb(data));\n            };\n        }\n        return this;\n    },\n    transform: function (cb) {\n        if (!extended.isFunction(cb)) {\n            this.emit(\"error\", new TypeError(\"fast-csv.Parser#transform requires a function\"));\n        }\n        if (cb.length === 2) {\n            this.__transform = cb;\n        } else {\n            this.__transform = function (data, next) {\n                return next(null, cb(data));\n            };\n        }\n        return this;\n    }\n\n});\n\nmodule.exports = ParserStream;"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;EACjCC,WAAW,GAAGF,QAAQ,CAACE,WAAW;EAClCC,UAAU,GAAGH,QAAQ,CAACG,UAAU;EAChCC,IAAI,GAAGH,OAAO,CAAC,MAAM,CAAC;EACtBI,GAAG,GAAGC,OAAO,CAACC,MAAM;EACpBC,MAAM,GAAGP,OAAO,CAAC,QAAQ,CAAC;EAC1BQ,KAAK,GAAG,0CAA0C;EAClDC,iBAAiB,GAAG,GAAG;EACvBC,YAAY,GAAGV,OAAO,CAAC,UAAU,CAAC;EAClCW,EAAE,GAAGX,OAAO,CAAC,IAAI,CAAC;EAClBY,WAAW,GAAG,CAAC,CAACL,MAAM,CAACM,SAAS,CAACC,SAAS,CAACC,QAAQ;AAEvD,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC3BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvBA,OAAO,CAACC,UAAU,GAAGnB,QAAQ,CAACoB,GAAG,CAACF,OAAO,EAAE,YAAY,CAAC,GAAGA,OAAO,CAACC,UAAU,GAAG,IAAI;EACpFX,MAAM,CAACM,SAAS,CAACO,IAAI,CAAC,IAAI,EAAEH,OAAO,CAAC;EACpC,IAAI,CAACI,KAAK,GAAG,EAAE;EACf,IAAI,CAACC,cAAc,GAAG,KAAK;EAC3B,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC;EACnB,IAAI,CAACC,SAAS,GAAG,KAAK;EACtB,IAAIC,SAAS;EACb,IAAI1B,QAAQ,CAACoB,GAAG,CAACF,OAAO,EAAE,WAAW,CAAC,EAAE;IACpCQ,SAAS,GAAGR,OAAO,CAACQ,SAAS;IAC7B,IAAIA,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,6CAA6C,CAAC;IAClE;IACAF,SAAS,GAAG1B,QAAQ,CAAC6B,MAAM,CAACH,SAAS,CAAC;EAC1C,CAAC,MAAM;IACHA,SAAS,GAAGhB,iBAAiB;EACjC;EACAQ,OAAO,CAACQ,SAAS,GAAGA,SAAS;EAC7B,IAAI,CAACI,MAAM,GAAGnB,YAAY,CAACO,OAAO,CAAC;EACnC,IAAI,CAACa,QAAQ,GAAGb,OAAO,CAACc,OAAO;EAC/B,IAAI,CAACC,YAAY,GAAGf,OAAO,CAACgB,WAAW;EACvC,IAAI,CAACC,uBAAuB,GAAGjB,OAAO,CAACkB,sBAAsB;EAC7D,IAAI,CAACC,qBAAqB,GAAGnB,OAAO,CAACoB,oBAAoB;EACzD,IAAI,CAACC,YAAY,GAAGrB,OAAO,CAACC,UAAU;EACtC,IAAI,CAACqB,UAAU,GAAG,EAAE;EACpB,OAAO,IAAI;AACf;AAEApC,IAAI,CAACqC,QAAQ,CAACxB,YAAY,EAAET,MAAM,CAACM,SAAS,CAAC;AAE7C,IAAI4B,MAAM,GAAGzB,YAAY,CAACF,SAAS,CAAC4B,EAAE;EAClCC,QAAQ,GAAG3B,YAAY,CAACF,SAAS,CAAC8B,IAAI;AAG1C7C,QAAQ,CAACiB,YAAY,CAAC,CAAC6B,MAAM,CAAC;EAE1BC,YAAY,EAAE,IAAI;EAElBC,YAAY,EAAE,KAAK;EAEnBC,aAAa,EAAE,KAAK;EAEpBC,YAAY,EAAE,SAASC,eAAeA,CAACC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAE;IAC9D,IAAIrB,WAAW,GAAG,IAAI,CAACD,YAAY;MAAEuB,IAAI,GAAG,IAAI;IAChD,IAAIxD,QAAQ,CAACyD,SAAS,CAACvB,WAAW,CAAC,IAAIA,WAAW,KAAK,CAACkB,IAAI,IAAI3C,KAAK,CAACiD,IAAI,CAACN,IAAI,CAACO,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;MACxF,OAAOJ,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;IAC3B;IACA,IAAI,CAACD,MAAM,EAAE;MACT,IAAI,CAACM,WAAW,CAACR,IAAI,EAAE,UAAUS,GAAG,EAAET,IAAI,EAAE;QACxC,IAAIS,GAAG,EAAE;UACLN,IAAI,CAACM,GAAG,CAAC;QACb,CAAC,MAAM;UACHL,IAAI,CAACM,UAAU,CAACV,IAAI,EAAE,UAAUS,GAAG,EAAEE,OAAO,EAAE;YAC1C,IAAIF,GAAG,EAAE;cACLN,IAAI,CAACM,GAAG,CAAC;YACb,CAAC,MAAM,IAAIE,OAAO,EAAE;cAChBR,IAAI,CAAC,IAAI,EAAEH,IAAI,CAAC;YACpB,CAAC,MAAM;cACHI,IAAI,CAACX,IAAI,CAAC,cAAc,EAAEO,IAAI,EAAEC,KAAK,CAAC;cACtCE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;YACpB;UACJ,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,OAAOA,IAAI,CAAC,IAAI,EAAEH,IAAI,CAAC;IAC3B;EACJ,CAAC;EAEDY,aAAa,EAAE,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAEC,EAAE,EAAE;IACrC,IAAIX,IAAI,GAAG,IAAI;MAAEY,KAAK;IACtBpE,QAAQ,CAACqE,SAAS,CAACJ,IAAI,EAAE,UAAUK,GAAG,EAAEH,EAAE,EAAE;MACxC,IAAIG,GAAG,EAAE;QACLd,IAAI,CAACN,YAAY,CAACoB,GAAG,EAAGF,KAAK,GAAG,EAAEZ,IAAI,CAAChC,SAAS,EAAG,KAAK,EAAE,UAAUqC,GAAG,EAAEU,OAAO,EAAE;UAC9E,IAAIV,GAAG,EAAE;YACLM,EAAE,CAACN,GAAG,CAAC;UACX,CAAC,MAAM;YACH,IAAIU,OAAO,EAAE;cACT,IAAI,CAACf,IAAI,CAACgB,cAAc,CAAC,CAAC,EAAE;gBACxBhB,IAAI,CAACiB,YAAY,CAACF,OAAO,EAAEH,KAAK,CAAC;cACrC,CAAC,MAAM;gBACHZ,IAAI,CAAChB,UAAU,CAACkC,IAAI,CAAC,CAACH,OAAO,EAAEH,KAAK,CAAC,CAAC;cAC1C;YACJ,CAAC,MAAM;cACHA,KAAK,GAAG,EAAEZ,IAAI,CAAChC,SAAS;YAC5B;YACA2C,EAAE,CAAC,CAAC;UACR;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,EAAE,UAAUN,GAAG,EAAE;MACd,IAAIA,GAAG,EAAE;QACLM,EAAE,CAACN,GAAG,CAAC;MACX,CAAC,MAAM;QACHM,EAAE,CAAC,IAAI,EAAED,IAAI,CAACd,IAAI,CAAC;MACvB;IACJ,CAAC,CAAC;EACN,CAAC;EAEDuB,gBAAgB,EAAE,SAAAA,CAAUV,IAAI,EAAEE,EAAE,EAAE;IAClC,IAAInC,OAAO,GAAG,IAAI,CAACD,QAAQ;MACvBK,sBAAsB,GAAG,IAAI,CAACD,uBAAuB;MACrDG,oBAAoB,GAAG,IAAI,CAACD,qBAAqB;MACjDmB,IAAI,GAAG,IAAI;IAEf,SAASoB,aAAaA,CAACf,GAAG,EAAE7B,OAAO,EAAE;MACjC,IAAI6B,GAAG,EAAE;QACLM,EAAE,CAACN,GAAG,CAAC;MACX,CAAC,MAAM,IAAI7D,QAAQ,CAAC6E,OAAO,CAAC7C,OAAO,CAAC,EAAE;QAClC,IAAI8C,aAAa,GAAG9C,OAAO,CAACL,MAAM;UAC9BoD,IAAI,GAAGvB,IAAI,CAACI,WAAW;QAC3BJ,IAAI,CAACI,WAAW,GAAG,UAAUM,IAAI,EAAEC,EAAE,EAAE;UACnC,IAAIa,GAAG,GAAG,CAAC,CAAC;YAAEC,CAAC,GAAG,CAAC,CAAC;YAAEC,GAAG;UACzB,IAAIhB,IAAI,CAACvC,MAAM,GAAGmD,aAAa,EAAE;YAC7B,IAAI1C,sBAAsB,EAAE;cACxB8B,IAAI,CAACiB,MAAM,CAACL,aAAa,CAAC;YAC9B,CAAC,MAAM,IAAIxC,oBAAoB,EAAE;cAC7BkB,IAAI,CAACX,IAAI,CAAC,cAAc,EAAEqB,IAAI,CAAC;cAC/B,OAAOa,IAAI,CAAC,IAAI,EAAEZ,EAAE,CAAC;YACzB,CAAC,MAAM;cACHX,IAAI,CAACX,IAAI,CAAC,OAAO,EAAE,IAAIjB,KAAK,CAAC,qDAAqD,GAAGkD,aAAa,GAAG,gBAAgB,GAAGZ,IAAI,CAACvC,MAAM,CAAC,CAAC;cACrI,OAAOoD,IAAI,CAAC,IAAI,EAAEZ,EAAE,CAAC;YACzB;UACJ,CAAC,MAAM,IAAI7B,oBAAoB,IAAK4B,IAAI,CAACvC,MAAM,GAAGmD,aAAc,EAAE;YAC9DtB,IAAI,CAACX,IAAI,CAAC,cAAc,EAAEqB,IAAI,CAAC;YAC/B,OAAOa,IAAI,CAAC,IAAI,EAAEZ,EAAE,CAAC;UACzB;UACA,OAAO,EAAEc,CAAC,GAAGH,aAAa,EAAE;YACxBI,GAAG,GAAGhB,IAAI,CAACe,CAAC,CAAC;YACbD,GAAG,CAAChD,OAAO,CAACiD,CAAC,CAAC,CAAC,GAAG/E,WAAW,CAACgF,GAAG,CAAC,GAAG,EAAE,GAAGA,GAAG;UACjD;UAEA,OAAOH,IAAI,CAACC,GAAG,EAAEb,EAAE,CAAC;QACxB,CAAC;MACL;MACAX,IAAI,CAACjC,cAAc,GAAG,IAAI;MAC1B4C,EAAE,CAAC,IAAI,CAAC;IACZ;IAEA,IAAInE,QAAQ,CAACyD,SAAS,CAACzB,OAAO,CAAC,IAAIA,OAAO,EAAE;MACxC,IAAI,CAACkB,YAAY,CAACe,IAAI,CAACmB,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAER,aAAa,CAAC;IAC3D,CAAC,MAAM;MACHA,aAAa,CAAC,IAAI,EAAE5C,OAAO,CAAC;IAChC;EAEJ,CAAC;EAEDqD,MAAM,EAAE,SAASC,UAAUA,CAACpB,IAAI,EAAEqB,WAAW,EAAEpB,EAAE,EAAE;IAC/C,IAAIF,IAAI;MAAET,IAAI,GAAG,IAAI;IACrB,IAAI;MACAU,IAAI,GAAG,IAAI,CAACpC,MAAM,CAACoC,IAAI,EAAEqB,WAAW,CAAC;MACrCtB,IAAI,GAAGC,IAAI,CAACD,IAAI;MAChB,IAAIA,IAAI,CAACtC,MAAM,EAAE;QACb,IAAI,CAAC,IAAI,CAACJ,cAAc,EAAE;UACtB,IAAI,CAACoD,gBAAgB,CAACV,IAAI,EAAE,UAAUJ,GAAG,EAAE;YACvC,IAAIA,GAAG,EAAE;cACLM,EAAE,CAACN,GAAG,CAAC;YACX,CAAC,MAAM;cACHL,IAAI,CAACQ,aAAa,CAACC,IAAI,EAAEC,IAAI,EAAEC,EAAE,CAAC;YACtC;UACJ,CAAC,CAAC;QACN,CAAC,MAAM;UACH,IAAI,CAACH,aAAa,CAACC,IAAI,EAAEC,IAAI,EAAEC,EAAE,CAAC;QACtC;MACJ,CAAC,MAAM;QACHA,EAAE,CAAC,IAAI,EAAED,IAAI,CAACd,IAAI,CAAC;MACvB;IACJ,CAAC,CAAC,OAAOoC,CAAC,EAAE;MACRrB,EAAE,CAACqB,CAAC,CAAC;IACT;EACJ,CAAC;EAEDf,YAAY,EAAE,SAAAA,CAAUF,OAAO,EAAEH,KAAK,EAAE;IACpC,IAAI,CAACvB,IAAI,CAAC,QAAQ,EAAE0B,OAAO,EAAEH,KAAK,CAAC;IACnC,IAAI,IAAI,CAAC3C,SAAS,EAAE;MAChB,IAAI,CAACiD,IAAI,CAAC,IAAI,CAACnC,YAAY,GAAGgC,OAAO,GAAGkB,IAAI,CAACC,SAAS,CAACnB,OAAO,CAAC,CAAC;IACpE;EACJ,CAAC;EAEDoB,UAAU,EAAE,SAAAA,CAAUzB,IAAI,EAAE0B,QAAQ,EAAEC,IAAI,EAAE;IACxC,IAAIvE,KAAK,GAAG,IAAI,CAACA,KAAK;MAClBwE,QAAQ,GAAIxE,KAAK,GAAG4C,IAAK;MACzBV,IAAI,GAAG,IAAI;IACf,IAAIsC,QAAQ,CAACnE,MAAM,GAAG,CAAC,EAAE;MACrB,IAAI,CAAC0D,MAAM,CAACS,QAAQ,EAAE,IAAI,EAAE,UAAUjC,GAAG,EAAEiC,QAAQ,EAAE;QACjD,IAAIjC,GAAG,EAAE;UACLgC,IAAI,CAAChC,GAAG,CAAC;QACb,CAAC,MAAM;UACHL,IAAI,CAAClC,KAAK,GAAGwE,QAAQ;UACrB,IAAI,CAACtC,IAAI,CAACgB,cAAc,CAAC,CAAC,EAAE;YACxBqB,IAAI,CAAC,CAAC;UACV,CAAC,MAAM;YACHrC,IAAI,CAACT,YAAY,GAAG8C,IAAI;UAC5B;QACJ;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,IAAI,CAACvE,KAAK,GAAGwE,QAAQ;MACrB,IAAI,CAAC,IAAI,CAACtB,cAAc,CAAC,CAAC,EAAE;QACxBqB,IAAI,CAAC,CAAC;MACV,CAAC,MAAM;QACH,IAAI,CAAC9C,YAAY,GAAG8C,IAAI;MAC5B;IACJ;EAEJ,CAAC;EAEDE,SAAS,EAAE,SAAAA,CAAUC,QAAQ,EAAE;IAC3B,IAAI;MACAA,QAAQ,CAAC,CAAC;IACd,CAAC,CAAC,OAAOR,CAAC,EAAE;MACRQ,QAAQ,CAACR,CAAC,CAAC;IACf;EACJ,CAAC;EAEDS,MAAM,EAAE,SAAAA,CAAUD,QAAQ,EAAE;IACxB,IAAIxC,IAAI,GAAG,IAAI;IACf,IAAI,IAAI,CAAClC,KAAK,EAAE;MACZ,IAAI,CAAC+D,MAAM,CAAC,IAAI,CAAC/D,KAAK,EAAE,KAAK,EAAE,UAAUuC,GAAG,EAAE;QAC1C,IAAIA,GAAG,EAAE;UACLmC,QAAQ,CAACnC,GAAG,CAAC;QACjB,CAAC,MAAM,IAAI,CAACL,IAAI,CAACgB,cAAc,CAAC,CAAC,EAAE;UAC/BhB,IAAI,CAACuC,SAAS,CAACC,QAAQ,CAAC;QAC5B,CAAC,MAAM;UACHxC,IAAI,CAACT,YAAY,GAAG,YAAY;YAC5BS,IAAI,CAACuC,SAAS,CAACC,QAAQ,CAAC;UAC5B,CAAC;QACL;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,IAAI,CAAC,IAAI,CAACxB,cAAc,CAAC,CAAC,EAAE;QACxB,IAAI,CAACuB,SAAS,CAACC,QAAQ,CAAC;MAC5B,CAAC,MAAM;QACH,IAAI,CAACjD,YAAY,GAAG,YAAY;UAC5BS,IAAI,CAACuC,SAAS,CAACC,QAAQ,CAAC;QAC5B,CAAC;MACL;IACJ;EACJ,CAAC;EAEDlC,UAAU,EAAE,SAAAA,CAAUI,IAAI,EAAEX,IAAI,EAAE;IAC9B,OAAOA,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;EAC3B,CAAC;EAEDK,WAAW,EAAE,SAAAA,CAAUM,IAAI,EAAEX,IAAI,EAAE;IAC/B,OAAOA,IAAI,CAAC,IAAI,EAAEW,IAAI,CAAC;EAC3B,CAAC;EAEDgC,mBAAmB,EAAE,SAAAA,CAAA,EAAY;IAC7B,IAAIC,QAAQ,GAAG,IAAI,CAAC3D,UAAU;MAAE4D,CAAC,GAAGD,QAAQ,CAACxE,MAAM;IACnD,IAAIyE,CAAC,EAAE;MACH,IAAIC,KAAK;MACT,OAAOF,QAAQ,CAACxE,MAAM,EAAE;QACpB0E,KAAK,GAAGF,QAAQ,CAACf,KAAK,CAAC,CAAC;QACxB,IAAI,CAACX,YAAY,CAAC4B,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;QACrC;QACA,IAAI,IAAI,CAAC7B,cAAc,CAAC,CAAC,EAAE;UACvB;QACJ;MACJ;MACA2B,QAAQ,CAACxE,MAAM,GAAG,CAAC;IACvB;IACA,IAAI,IAAI,CAACoB,YAAY,EAAE;MACnB,IAAI8C,IAAI,GAAG,IAAI,CAAC9C,YAAY;MAC5B,IAAI,CAACA,YAAY,GAAG,IAAI;MACxB8C,IAAI,CAAC,CAAC;IACV;EACJ,CAAC;EAEDrB,cAAc,EAAE,SAAAA,CAAA,EAAY;IACxB,OAAO,IAAI,CAAC8B,QAAQ;EACxB,CAAC;EAEDzD,IAAI,EAAE,SAAAA,CAAU0D,KAAK,EAAE;IACnB,IAAIA,KAAK,KAAK,KAAK,EAAE;MACjB,IAAI,CAAC,IAAI,CAACvD,YAAY,EAAE;QACpB,IAAI,CAACA,YAAY,GAAG,IAAI;QACxB7C,UAAU,CAACyC,QAAQ,EAAE,CAAC,KAAK,EAAE,EAAE,IAAI,CAACpB,SAAS,CAAC,EAAE,IAAI,CAAC;MACzD;IACJ,CAAC,MAAM;MACH,IAAI,CAACX,WAAW,EAAE;QACd,IAAI0F,KAAK,KAAK,OAAO,EAAE;UACnB,IAAI,CAACD,QAAQ,GAAG,IAAI;QACxB,CAAC,MAAM,IAAIC,KAAK,KAAK,QAAQ,EAAE;UAC3B,IAAI,CAACD,QAAQ,GAAG,KAAK;UACrB,IAAI,CAACJ,mBAAmB,CAAC,CAAC;QAC9B;MACJ;MACA/F,UAAU,CAACyC,QAAQ,EAAE4D,SAAS,EAAE,IAAI,CAAC;IACzC;EACJ,CAAC;EAED7D,EAAE,EAAE,SAAAA,CAAU8D,GAAG,EAAE;IACf,IAAIA,GAAG,KAAK,MAAM,IAAIA,GAAG,KAAK,UAAU,EAAE;MACtC,IAAI,CAAChF,SAAS,GAAG,IAAI;IACzB;IACAtB,UAAU,CAACuC,MAAM,EAAE8D,SAAS,EAAE,IAAI,CAAC;IACnC,OAAO,IAAI;EACf,CAAC;EAEDE,QAAQ,EAAE,SAAAA,CAAUvC,EAAE,EAAE;IACpB,IAAI,CAACnE,QAAQ,CAAC2G,UAAU,CAACxC,EAAE,CAAC,EAAE;MAC1B,IAAI,CAACtB,IAAI,CAAC,OAAO,EAAE,IAAI+D,SAAS,CAAC,8CAA8C,CAAC,CAAC;IACrF;IACA,IAAIzC,EAAE,CAACxC,MAAM,KAAK,CAAC,EAAE;MACjB,IAAI,CAACmC,UAAU,GAAGK,EAAE;IACxB,CAAC,MAAM;MACH,IAAI,CAACL,UAAU,GAAG,UAAUI,IAAI,EAAEX,IAAI,EAAE;QACpC,OAAOA,IAAI,CAAC,IAAI,EAAEY,EAAE,CAACD,IAAI,CAAC,CAAC;MAC/B,CAAC;IACL;IACA,OAAO,IAAI;EACf,CAAC;EACD2C,SAAS,EAAE,SAAAA,CAAU1C,EAAE,EAAE;IACrB,IAAI,CAACnE,QAAQ,CAAC2G,UAAU,CAACxC,EAAE,CAAC,EAAE;MAC1B,IAAI,CAACtB,IAAI,CAAC,OAAO,EAAE,IAAI+D,SAAS,CAAC,+CAA+C,CAAC,CAAC;IACtF;IACA,IAAIzC,EAAE,CAACxC,MAAM,KAAK,CAAC,EAAE;MACjB,IAAI,CAACiC,WAAW,GAAGO,EAAE;IACzB,CAAC,MAAM;MACH,IAAI,CAACP,WAAW,GAAG,UAAUM,IAAI,EAAEX,IAAI,EAAE;QACrC,OAAOA,IAAI,CAAC,IAAI,EAAEY,EAAE,CAACD,IAAI,CAAC,CAAC;MAC/B,CAAC;IACL;IACA,OAAO,IAAI;EACf;AAEJ,CAAC,CAAC;AAEF4C,MAAM,CAACC,OAAO,GAAG9F,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}